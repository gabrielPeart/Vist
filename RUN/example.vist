


func dupe :: Int -> Int Int = (a) do return (a, a)

func factorial :: Int -> Int = (a) do
if a <= 1 do
return 1
else do
return a * factorial a - 1


print (factorial 1) // test: 1
print (factorial 10) // test: 3628800
print (factorial 1 + 3) // test: 24

let dupe = dupe 2
let w = factorial dupe.0 + dupe.1
print w // test: 24

print (factorial (factorial 3)) // test: 720


func void :: () = do print 41

void () // test: 41


func two :: -> Int = do return 2

print (two ()) // test: 2

/*
// type foo, { i64 i64 } type
// implicit memberwise initialser is added
type StackOf2 {
    var a: Int
    var b: Int
    
    func sum :: () -> Int = do return a + b
    func pop :: () -> Int = do return b
    
    func removeB :: -> Int = {
        let v = b
        b = 0
        return v
    }
    
    // mutating methods
    // by passing self as a pointer
}

func push :: Int StackOf2 -> StackOf2 = (val stack) do
    return StackOf2 stack.b val

func empty :: -> StackOf2 = do
    return StackOf2 0 0


var stack = StackOf2 2 10

print (stack.sum ())
// test: 12

stack = push 3 stack
print (stack.pop ())
// test: 3

stack = empty ()

print stack.a == stack.b
// test: true
*/
