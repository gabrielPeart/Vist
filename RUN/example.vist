
concept TestC {
    var t: Int
}

type Foo {
    var t: Int
}

type Bar {
    var foo: TestC
}

let b = Bar (Foo 1)
let u = b.foo.t
print u // test: 1


func dupe :: Int -> Int Int = (a) do return (a, a)

func factorial :: Int -> Int = (a) do
if a <= 1 do
return 1
else do
return a * factorial a - 1


print (factorial 1) // test: 1
print (factorial 10) // test: 3628800
print (factorial 1 + 3) // test: 24

let dupe = dupe 2
let w = factorial dupe.0 + dupe.1
print w // test: 24

print (factorial (factorial 3)) // test: 720


func void :: () = do print 41

void () // test: 41


func two :: -> Int = do return 2

print (two ()) // test: 2


let a = 3

if a < 2 * 100 do print 100

// test: 100


if a > 4 {
    print 1
}
else if a == 3 {
    print 11 // test: 11
}


if false {
    print 1
}
else if false {
    print false
}
else {
    print 20 // test: 20
}



/*
concept Eq {
    var t: Int
}


type Bar (T | Eq) {
    let t: T
}
 */

// todo: IRGen.swift, l1060, fix the lookup of props on prop lookups
// todo: cacheing ptrs in immutable structs
// todo: existential properties & storing



//concept Any { }


/*

 
 
type Foo {
    var a: Int
}





type Bar (T | Eq) {
    let t: T
}


let b = (Foo 1)
*/

//func foo T :: T T -> Bool = (a b) do
//    return true







//type Array (Element | Foo Bar) {
//
//    var count: Int
//    var capacity: Int
//    var ptr: LLVM.Pointer
//}




// constrained by Eq
//func equal (T | Eq) :: T T -> Bool = (a b) do
//    return a == b


