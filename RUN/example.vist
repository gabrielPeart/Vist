


concept Foo { var v: Int }
type Bar { var v: Int }

func fn :: Foo = (f) {
    print f.v
    print f.v
    print f.v
    print f.v
}

fn (Bar 12)


//for i in 0 ... 1000 do
//    print 1





/*
type I { var v: Int }
concept X { var i: I }
type A { var i: I }
type B { var a: X }

var u = B (A (I 1))

u.a.i.v = 2

print u.a.i.v

let x = ( (1, u), 2)

x. 0 . 1 . a.i.v = 11
*/


/*
concept Eq {
    var t: Int
}


type Bar (T | Eq) {
    let t: T
}
 */

// todo: cacheing ptrs in immutable structs
// todo: existential properties & storing



//concept Any { }


/*

 
 
type Foo {
    var a: Int
}





type Bar (T | Eq) {
    let t: T
}


let b = (Foo 1)
*/

//func foo T :: T T -> Bool = (a b) do
//    return true







//type Array (Element | Foo Bar) {
//
//    var count: Int
//    var capacity: Int
//    var ptr: LLVM.Pointer
//}




// constrained by Eq
//func equal (T | Eq) :: T T -> Bool = (a b) do
//    return a == b


