

let a = 3
print a



concept Eq {
    var t: Int
}

type Foo {
    var t: Int
}

type Bar {
    var foo: Eq
}

let f = Foo 1
let b = Bar f
let u = b.foo.t
print u


let w = ( (Bar (Foo 4)) , 1)
let xx = w.0 .foo.t
print xx









/*
concept Eq {
    var t: Int
}


type Bar (T | Eq) {
    let t: T
}
 */

// todo: IRGen.swift, l1060, fix the lookup of props on prop lookups
// todo: cacheing ptrs in immutable structs
// todo: existential properties & storing



//concept Any { }


/*

 
 
type Foo {
    var a: Int
}





type Bar (T | Eq) {
    let t: T
}


let b = (Foo 1)
*/

//func foo T :: T T -> Bool = (a b) do
//    return true







//type Array (Element | Foo Bar) {
//
//    var count: Int
//    var capacity: Int
//    var ptr: LLVM.Pointer
//}




// constrained by Eq
//func equal (T | Eq) :: T T -> Bool = (a b) do
//    return a == b


