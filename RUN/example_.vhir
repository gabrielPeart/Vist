
type %Int = { %Builtin.Int64 }
type %Int32 = { %Builtin.Int32 }
type %Double = { %Builtin.Double }
type %Bool = { %Builtin.Bool }
type %Range = { %Int, %Int }

func @Bool_ : &thin () -> %Bool {
$entry:
  %self = alloc %Bool  	// users: %value, %4
  %value = struct_element %self: %*Bool, #Bool.value  	// user: %3
  %0 = bool_literal false  	// user: %1
  %1 = struct %Bool (%0: %Builtin.Bool)  	// user: %b
  variable_decl %b = %1: %Bool  	// user: %2
  %2 = struct_extract %b: %Bool, #Bool.value  	// user: %3
  store %2 in %value: %*b 
  %4 = load %self: %*Bool  	// user: %5
  return %4
}

func @print_Bool : &thin (%Bool) -> %Builtin.Void {
$entry(%a: %Bool):
  %0 = struct_extract %a: %Bool, #Bool.value  	// user: %1
  %1 = call @-Uprint_b (%0: %Builtin.Bool) 
  return ()
}

func @-Uprint_b : &thin (%Builtin.Bool) -> %Builtin.Void

func @condFail_b : &thin (%Builtin.Bool) -> %Builtin.Void {
$entry(%cond: %Builtin.Bool):
  %0 = call @Bool_b (%cond: %Builtin.Bool)  	// user: %3
  %1 = bool_literal false  	// user: %2
  %2 = struct %Bool (%1: %Builtin.Bool)  	// user: %3
  %3 = call @-Uexpect_Bool_Bool (%0: %Bool, %2: %Bool)  	// user: %4
  %4 = struct_extract %3: %Bool, #Bool.value  	// user: 
  break %4: %Builtin.Bool, $if.0, $exit

$if.0:			// preds: entry
  %6 = builtin trap  
  break $exit

$exit:			// preds: entry, if.0
  return ()
}

func @-E-E_Int_Int : &thin (%Int, %Int) -> %Bool {
$entry(%a: %Int, %b: %Int):
  %0 = struct_extract %a: %Int, #Int.value  	// user: %2
  %1 = struct_extract %b: %Int, #Int.value  	// user: %2
  %2 = builtin i_eq %0: %Builtin.Int64, %1: %Builtin.Int64  	// user: %3
  %3 = call @Bool_b (%2: %Builtin.Bool)  	// user: %4
  return %3
}

func @Bool_b : &thin (%Builtin.Bool) -> %Bool {
$entry(%$0: %Builtin.Bool):
  %self = alloc %Bool  	// users: %value, %1
  %value = struct_element %self: %*Bool, #Bool.value  	// user: %0
  store %$0 in %value: %*b 
  %1 = load %self: %*Bool  	// user: %2
  return %1
}

func @print_Int32 : &thin (%Int32) -> %Builtin.Void {
$entry(%a: %Int32):
  %0 = struct_extract %a: %Int32, #Int32.value  	// user: %1
  %1 = call @-Uprint_i32 (%0: %Builtin.Int32) 
  return ()
}

func @-P_Int_Int : &thin (%Int, %Int) -> %Int {
$entry(%a: %Int, %b: %Int):
  %0 = struct_extract %a: %Int, #Int.value  	// user: %2
  %1 = struct_extract %b: %Int, #Int.value  	// user: %2
  %2 = builtin i_add %0: %Builtin.Int64, %1: %Builtin.Int64  	// user: %v
  variable_decl %v = %2: (%Builtin.Int64, %Builtin.Bool)  	// users: %3, %5
  %3 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 1  	// user: %4
  cond_fail %3: %Builtin.Bool
  %5 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 0  	// user: %6
  %6 = call @Int_i64 (%5: %Builtin.Int64)  	// user: %7
  return %6
}

func @-M_Int_Int : &thin (%Int, %Int) -> %Int {
$entry(%a: %Int, %b: %Int):
  %0 = struct_extract %a: %Int, #Int.value  	// user: %2
  %1 = struct_extract %b: %Int, #Int.value  	// user: %2
  %2 = builtin i_sub %0: %Builtin.Int64, %1: %Builtin.Int64  	// user: %v
  variable_decl %v = %2: (%Builtin.Int64, %Builtin.Bool)  	// users: %3, %5
  %3 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 1  	// user: %4
  %4 = call @condFail_b (%3: %Builtin.Bool) 
  %5 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 0  	// user: %6
  %6 = call @Int_i64 (%5: %Builtin.Int64)  	// user: %7
  return %6
}

func @Range_Int_Int : &thin (%Int, %Int) -> %Range {
$entry(%$0: %Int, %$1: %Int):
  %self = alloc %Range  	// users: %start, %end, %2
  %start = struct_element %self: %*Range, #Range.start  	// user: %0
  %end = struct_element %self: %*Range, #Range.end  	// user: %1
  store %$0 in %start: %*Int 
  store %$1 in %end: %*Int 
  %2 = load %self: %*Range  	// user: %3
  return %2
}

func @-A_Int_Int : &thin (%Int, %Int) -> %Int {
$entry(%a: %Int, %b: %Int):
  %0 = struct_extract %a: %Int, #Int.value  	// user: %2
  %1 = struct_extract %b: %Int, #Int.value  	// user: %2
  %2 = builtin i_mul %0: %Builtin.Int64, %1: %Builtin.Int64  	// user: %v
  variable_decl %v = %2: (%Builtin.Int64, %Builtin.Bool)  	// users: %3, %5
  %3 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 1  	// user: %4
  %4 = call @condFail_b (%3: %Builtin.Bool) 
  %5 = tuple_extract %v: (%Builtin.Int64, %Builtin.Bool), 0  	// user: %6
  %6 = call @Int_i64 (%5: %Builtin.Int64)  	// user: %7
  return %6
}

func @-Uprint_f64 : &thin (%Builtin.Double) -> %Builtin.Void

func @Int_i64 : &thin (%Builtin.Int64) -> %Int {
$entry(%$0: %Builtin.Int64):
  %self = alloc %Int  	// users: %value, %1
  %value = struct_element %self: %*Int, #Int.value  	// user: %0
  store %$0 in %value: %*i64 
  %1 = load %self: %*Int  	// user: %2
  return %1
}

func @-Uprint_i64 : &thin (%Builtin.Int64) -> %Builtin.Void

func @-Uprint_i32 : &thin (%Builtin.Int32) -> %Builtin.Void

func @print_Double : &thin (%Double) -> %Builtin.Void {
$entry(%a: %Double):
  %0 = struct_extract %a: %Double, #Double.value  	// user: %1
  %1 = call @-Uprint_f64 (%0: %Builtin.Double) 
  return ()
}

func @Int32_i32 : &thin (%Builtin.Int32) -> %Int32 {
$entry(%$0: %Builtin.Int32):
  %self = alloc %Int32  	// users: %value, %1
  %value = struct_element %self: %*Int32, #Int32.value  	// user: %0
  store %$0 in %value: %*i32 
  %1 = load %self: %*Int32  	// user: %2
  return %1
}

func @Int_ : &thin () -> %Int {
$entry:
  %self = alloc %Int  	// users: %value, %4
  %value = struct_element %self: %*Int, #Int.value  	// user: %3
  %0 = int_literal 0  	// user: %1
  %1 = struct %Int (%0: %Builtin.Int64)  	// user: %v
  variable_decl %v = %1: %Int  	// user: %2
  %2 = struct_extract %v: %Int, #Int.value  	// user: %3
  store %2 in %value: %*i64 
  %4 = load %self: %*Int  	// user: %5
  return %4
}

func @Double_f64 : &thin (%Builtin.Double) -> %Double {
$entry(%$0: %Builtin.Double):
  %self = alloc %Double  	// users: %value, %1
  %value = struct_element %self: %*Double, #Double.value  	// user: %0
  store %$0 in %value: %*f64 
  %1 = load %self: %*Double  	// user: %2
  return %1
}

func @-Uexpect_Bool_Bool : &thin (%Bool, %Bool) -> %Bool {
$entry(%val: %Bool, %assume: %Bool):
  %0 = struct_extract %val: %Bool, #Bool.value  	// user: %2
  %1 = struct_extract %assume: %Bool, #Bool.value  	// user: %2
  %2 = builtin expect %0: %Builtin.Bool, %1: %Builtin.Bool  	// user: %3
  %3 = call @Bool_b (%2: %Builtin.Bool)  	// user: %4
  return %3
}

func @fatalError_ : &thin () -> %Builtin.Void {
$entry:
  %0 = builtin trap  
  return ()
}

func @main : &thin () -> %Builtin.Void {
$entry:
  return ()
}

func @print_Int : &thin (%Int) -> %Builtin.Void {
$entry(%a: %Int):
  %0 = struct_extract %a: %Int, #Int.value  	// user: %1
  %1 = call @-Uprint_i64 (%0: %Builtin.Int64) 
  return ()
}

func @assert_Bool : &thin (%Bool) -> %Builtin.Void {
$entry(%$0: %Bool):
  %0 = bool_literal true  	// user: %1
  %1 = struct %Bool (%0: %Builtin.Bool)  	// user: %2
  %2 = call @-Uexpect_Bool_Bool (%$0: %Bool, %1: %Bool)  	// user: %3
  %3 = struct_extract %2: %Bool, #Bool.value  	// user: 
  break %3: %Builtin.Bool, $if.0, $fail.0

$if.0:			// preds: entry
  break $exit

$fail.0:			// preds: entry
  break $else.1

$else.1:			// preds: fail.0
  %7 = builtin trap  
  break $exit

$exit:			// preds: if.0, else.1
  return ()
}