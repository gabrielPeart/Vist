
type %Int = { %Builtin.Int64 }
type %Foo = existential < %Int, %Bool >
type %Bool = { %Builtin.Bool }
type %Bar = { %Int, %Int, %Bool }
type %Bar = { %Int, %Int, %Bool }

func @unbox_Foo : &thin (%Foo) -> %Int {
$entry(%box: %Foo):
  %0 = alloc %Foo  	// users: %1, %2
  store %box in %0: %*Foo 
  %2 = existential_open %0: %*Foo #a  	// user: %3
  return %2
}

func @Foo.aye_ : &thin () -> %Int

func @Bar.aye_ : &method (%*Bar) -> %Int {
$entry(%self: %*Bar):
  %c = struct_element %self: %*Bar, #c  	// user: %0
  %0 = load %c: %*Bool  	// user: %1
  %1 = struct_extract %0: %Bool, #value  	// user: 
  break %1: %Builtin.Bool, $if.0, $fail.0

$if.0:			// preds: entry
  %a = struct_element %self: %*Bar, #a  	// user: %3
  %3 = load %a: %*Int  	// user: %4
  return %3

$fail.0:			// preds: entry
  break $else.1

$else.1:			// preds: fail.0
  %b = struct_element %self: %*Bar, #b  	// user: %6
  %6 = load %b: %*Int  	// user: %7
  return %6
}

func @Bar_Int_Int_Bool : &thin (%Int, %Int, %Bool) -> %Bar {
$entry(%$0: %Int, %$1: %Int, %$2: %Bool):
  %self = alloc %Bar  	// users: %b, %a, %c, %3
  %b = struct_element %self: %*Bar, #b  	// user: %0
  %a = struct_element %self: %*Bar, #a  	// user: %1
  %c = struct_element %self: %*Bar, #c  	// user: %2
  store %$0 in %b: %*Int 
  store %$1 in %a: %*Int 
  store %$2 in %c: %*Bool 
  %3 = load %self: %*Bar  	// user: %4
  return %3
}

func @main : &thin () -> %Builtin.Void {
$entry:
  %0 = int_literal 1  	// user: %1
  %1 = struct %Int (%0: %Builtin.Int64)  	// user: %6
  %2 = int_literal 2  	// user: %3
  %3 = struct %Int (%2: %Builtin.Int64)  	// user: %6
  %4 = bool_literal false  	// user: %5
  %5 = struct %Bool (%4: %Builtin.Bool)  	// user: %6
  %6 = call @Bar_Int_Int_Bool (%1: %Int, %3: %Int, %5: %Bool)  	// user: %b
  variable_decl %b = %6: %Bar  	// users: %8, %13
  %7 = alloc %Bar  	// users: %8, %9
  store %b in %7: %*Bar 
  %9 = existential_box %7: %*Bar in %Foo  	// user: %10
  %10 = call @unbox_Foo (%9: %Foo)  	// user: %a
  variable_decl %a = %10: %Int  	// user: %11
  %11 = call @print_Int (%a: %Int) 
  %12 = alloc %Bar  	// users: %13, %14
  store %b in %12: %*Bar 
  %14 = existential_box %12: %*Bar in %Foo  	// user: %15
  %15 = call @callAye_Foo (%14: %Foo)  	// user: %16
  %16 = call @print_Int (%15: %Int) 
  return ()
}

func @print_Int : &thin (%Int) -> %Builtin.Void

func @callAye_Foo : &thin (%Foo) -> %Int {
$entry(%box: %Foo):
  %0 = alloc %Foo  	// users: %1, %unboxed
  store %box in %0: %*Foo 
  %witness = existential_witness %0: %*Foo #aye  	// user: 
  %unboxed = existential_unbox %0: %*Foo  	// user: %2
  %2 = call %witness: %* (%unboxed: %*Builtin.Int8)  	// user: %3
  return %2
}