

// ----------------------------------------------------
// types
// ----------------------------------------------------

/*
type UTF8View {
    var chars: Builtin.OpaquePointer
    var size: Int
    
    init () = {
        chars = Builtin.heap_alloc 100
        size = 0
    }
    
    funcAdd
}
*/

/// initialises a swift string representing an integer
func int64ToString :: Int -> String = (number) {
    
    let size = 20 // max possibly 64 bit int is 19 chars, plus 1 for null
    let buffer = Builtin.stack_alloc size.value // alloc buffer
    
    var bufferSize = 1 // start with buffer size 1 for the null terminator
    var val = number
    var ptr = buffer + size // the end of the buffer
    
    while val != 0 {
        ptr = ptr - 1 // move back a char
        
        let v = val % 10 + 48 // magic number '48' shifts 0 to the correct unicode code point
        let char = Builtin.trunc_int_8 v.value // get a characrer
        
        Builtin.opaque_store ptr char // store char in string
        
        val = val / 10 // remove the last (just added) digit
        bufferSize = bufferSize + 1 // inc buffer size
    }
    
    let isUTF8 = true
    let s = String ptr bufferSize.value isUTF8.value
    return s
}

type Int {
    var value: Builtin.Int64
    
    init () = {
        let v = 0
        value = v.value
    }
    init Int = (val) do value = val.value
    
    func description :: -> String = {
        return int64ToString self
    }
}
type Int32 {
    var value: Builtin.Int32
    init Int32 = (val) do value = val.value
}
type Int8 {
    var value: Builtin.Int8
}

type Bool {
    var value: Builtin.Bool
    
    init () = {
        let b = false
        value = b.value
    }
    init Bool = (val) do value = val.value
}

type Double {
    var value: Builtin.Double
    init Double = (val) do value = val.value
}




//type Array {
//
//    var count: Int
//    var capacity: Int
//    var ptr: Builtin.Pointer
//
//}


// ----------------------------------------------------
// free functions
// ----------------------------------------------------

@public @inline func print :: Int32 = (a) do vist_print a.value
@public @inline func print :: Bool = (a) do vist_print a.value
@public @inline func print :: Double = (a) do vist_print a.value


// TODO: print message

@inline func _expect :: Bool Bool -> Bool = (val assume) do
    return Bool (Builtin.expect val.value assume.value)

@public @inline @noreturn func fatalError :: () = do Builtin.trap ()
//@public @inline func assert :: Bool = do
//    if _expect $0 true do () else do Builtin.trap ()



// ----------------------------------------------------
// operators
// ----------------------------------------------------


@public @inline @operator(80)
func + :: Builtin.OpaquePointer Int -> Builtin.OpaquePointer = (pointer offset) do
    return Builtin.advance_pointer pointer offset.value

@public @inline @operator(80)
func - :: Builtin.OpaquePointer Int -> Builtin.OpaquePointer = (pointer offset) {
    let s = 0 - offset
    return Builtin.advance_pointer pointer s.value
}

// int
@public @inline @operator(80)
func + :: Int Int -> Int = (a b) {
    let v = Builtin.i_add a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(80)
func - :: Int Int -> Int = (a b) {
    let v = Builtin.i_sub a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(100)
func * :: Int Int -> Int = (a b) {
    let v = Builtin.i_mul a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(20)
func == :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_eq a.value b.value)

@public @inline @operator(20)
func != :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_neq a.value b.value)

@public @inline @operator(100)
func / :: Int Int -> Int = (a b) {
    //assert b != 0
    return Int (Builtin.i_div a.value b.value)
}
@public @inline @operator(90)
func % :: Int Int -> Int = (a b) do
    return Int (Builtin.i_rem a.value b.value)

@public @inline @operator(30)
func < :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lte a.value b.value)

@public @inline @operator(30)
func >= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gte a.value b.value)

@public @inline @operator(30)
func > :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gt a.value b.value)

@public @inline @operator(50)
func << :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shl a.value b.value)

@public @inline @operator(50)
func >> :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shr a.value b.value)

@public @inline @operator(95)
func ~& :: Int Int -> Int = (a b) do
    return Int (Builtin.i_and a.value b.value)

@public @inline @operator(90)
func ~| :: Int Int -> Int = (a b) do
    return Int (Builtin.i_or a.value b.value)

@public @inline @operator(90)
func ~^ :: Int Int -> Int = (a b) do
    return Int (Builtin.i_xor a.value b.value)



// bool
@public @inline @operator(15)
func && :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_and a.value b.value)

@public @inline @operator(10)
func || :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_or a.value b.value)
// TODO:: ! prefix operator


// float
@public @inline @operator(80)
func + :: Double Double -> Double = (a b) do
    return Double (Builtin.f_add a.value b.value)

@public @inline @operator(80)
func - :: Double Double -> Double = (a b) do
    return Double (Builtin.f_sub a.value b.value)

@public @inline @operator(100)
func * :: Double Double -> Double = (a b) do
    return Double (Builtin.f_mul a.value b.value)

@public @inline @operator(100)
func / :: Double Double -> Double = (a b) do
    return Double (Builtin.f_div a.value b.value)

@public @inline @operator(90)
func % :: Double Double -> Double = (a b) do
    return Double (Builtin.f_rem a.value b.value)

@public @inline @operator(30)
func < :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lte a.value b.value)

@public @inline @operator(30)
func > :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gt a.value b.value)

@public @inline @operator(30)
func >= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gte a.value b.value)

@public @inline @operator(20)
func == :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_eq a.value b.value)

@public @inline @operator(20)
func != :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_neq a.value b.value)





type Range {
    var start: Int, end: Int
    init Range = (val) {
        start = val.start
        end = val.end
    }
    
    /// A generator -- yields each element in the range
    func generate:: -> Int = {
        var i = start
        while (i < end) {
            yield i
            i = i + 1
        }
    }
}

// ranges
@public @inline @operator(40)
func ... :: Int Int -> Range = (a b) do
    return Range a b

@public @inline @operator(40)
func ..< :: Int Int -> Range = (a b) do
    return Range a b-1




type UTF8CodeUnit {
    let unit: Builtin.Int8
    
    init Int = (u) {
        unit = Builtin.trunc_int_8 u.value
    }
}

type UTF16CodeUnit {
    let unit: Builtin.Int16
    
    init Int = (u) {
        unit = Builtin.trunc_int_16 u.value
    }
}

/*
type Pointer {
    var memory: Builtin.OpaquePointer
    
    init Int = (size) {
        memory = Builtin.heap_alloc size.value
    }
    
    func store :: Int = (val) {
        let char = Builtin.trunc_int_8 val.value
        Builtin.opaque_store memory char
    }
    
}
*/

ref type _StringCore {
    var _base: Builtin.OpaquePointer, _capacity: Int, _isUTF8Encoded: Bool, _length: Int
    
    @mutating func growBufferTo:: Int = (newSize) {
        let newBuffer = Builtin.heap_alloc newSize.value
        
        Builtin.mem_copy newBuffer _base _capacity.value
        Builtin.heap_free _base
        
        _base = newBuffer
        _capacity = newSize
    }
    
    /*
    func getCoreCopy:: -> _StringCore = {
        // copy buffer
        let newBuffer = Builtin.heap_alloc _capacity.value
        Builtin.mem_copy newBuffer _base _capacity.value
        // construct new core
        return _StringCore newBuffer _capacity _isUTF8Encoded _length
    }
    
    func addUTF8CodeUnit:: UTF8CodeUnit = (unit) {
        
    }
    func addUTF16CodeUnit:: UTF16CodeUnit = (unit) {
        
    }
     */
    
    /// Return a pointer to the code unit `offset` from `base`
    /// temporary substitute until I have StringCore subscripting
    func codeUnitAtOffset:: Int -> Builtin.OpaquePointer = (offset) do
        return _base + offset
}

type String {
    var core: _StringCore
    
    init Builtin.OpaquePointer Builtin.Int Builtin.Bool = (ptr count isUTF8Encoded) {
        // allocate the string buffer and copy in from the string ptr we are given
        let base = Builtin.heap_alloc count
        Builtin.mem_copy base ptr count
        
        let c = Int count
        let l = c - 1
        let isutf8 = Bool isUTF8Encoded
        core = _StringCore base c isutf8 l
    }
    
    //@private init UTF8CodeUnit = (unit) {
    //    let b = Builtin.heap_alloc 2 // alloc 2 bytes
    //    let s = String
    //}
    
    func _checkUniquelyReferencedCore:: () = {
        
    }
    
    /// A genrator -- yields each code unit
    func generate:: -> UTF8CodeUnit = {
        var i = 0
        while (i < core._capacity) {
            yield UTF8CodeUnit (Builtin.opaque_load (core.codeUnitAtOffset i))
            i = i + 1
        }
    }
}


@inline func _print :: String = (str) {
    let core = str.core
    if (core._isUTF8Encoded) {
        // if its all UTF-8 we can just fwrite the buffer
        vist_cshim_write str.core._base core._length.value
        return ()
    } else {
        // otherwise we step through, char by char, and putchar it
        for c in str do
            vist_cshim_putchar c.unit
        return ()
    }
    // there's a CFG bug where implict `return ()` are only added to the exit point
}

@public func print :: String = (str) {
    _print str
    _print "\n"
}

@public @inline func print :: Int = (a) {
    _print (a.description ())
    _print "\n"
}

// TODO: a printing protocol which allows any type to generate its string repr
//       then the print function steps through that string and prints it,
//       appending terminators and doing any formatting

//concept Printable {
//    func description::->String
//}
//
//func print::Printable = (thing) do


