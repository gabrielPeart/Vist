

// ----------------------------------------------------
// types
// ----------------------------------------------------


/// initialises a swift string representing an integer
func int64ToString :: Int -> String = (number) {
    
    let size = 20 // max possible 64 bit int is 19 chars, plus 1 for null
    let buffer = Builtin.stack_alloc size.value // alloc buffer
    
    var bufferSize = 1 // start with buffer size 1 for the null terminator
    var val = number
    var ptr = buffer + size // the end of the buffer

    // if our num is 0, we return "0"
    if number == 0 { return "0" }
    let isNegative = number < 0
    
    if (isNegative) {
        val = 0 - val
    }

    while val != 0 {
        ptr = ptr - 1 // move back a char
        
        let v = val % 10 + 48 // magic number '48' shifts 0 to the correct unicode code point
        let char = Builtin.trunc_int_8 v.value // get a characrer
        
        Builtin.opaque_store ptr char // store char in string
        
        val = val / 10 // remove the last (just added) digit
        bufferSize = bufferSize + 1 // inc buffer size
    }
    
    if (isNegative) {
        ptr = ptr - 1
        let minus = 45 
        let char = Builtin.trunc_int_8 minus.value
        
        Builtin.opaque_store ptr char
        bufferSize = bufferSize + 1 // inc buffer size
    }
    
    let isUTF8 = true
    let s = String ptr bufferSize.value isUTF8.value
    return s
}

type Int {
    var value: Builtin.Int64
    
    init () = {
        let v = 0
        value = v.value
    }
    init Int = (val) do value = val.value
    
    func description :: -> String = do
        return int64ToString self
    
}
type Int32 {
    var value: Builtin.Int32
    init Int32 = (val) do value = val.value
}

type Bool {
    var value: Builtin.Bool
    
    init () = {
        let b = false
        value = b.value
    }
    init Bool = (val) do value = val.value

    func description :: -> String = do
        if self do return "true"
           else do return "false"
}

type Double {
    var value: Builtin.Double
    init Double = (val) do value = val.value
}


// ----------------------------------------------------
// free functions
// ----------------------------------------------------

@public @inline func print :: Int32 = (a) do vist_cshim_print a.value
@public @inline func print :: Double = (a) do vist_cshim_print a.value


// TODO: print message

@inline func _expect :: Bool Bool -> Bool = (val assume) do
    return Bool (Builtin.expect val.value assume.value)

@public @inline @noreturn func fatalError :: () = do Builtin.trap ()
//@public @inline func assert :: Bool = do
//    if _expect $0 true do () else do Builtin.trap ()



// ----------------------------------------------------
// operators
// ----------------------------------------------------


@public @inline @operator(80)
func + :: Builtin.OpaquePointer Int -> Builtin.OpaquePointer = (pointer offset) do
    return Builtin.advance_pointer pointer offset.value

@public @inline @operator(80)
func - :: Builtin.OpaquePointer Int -> Builtin.OpaquePointer = (pointer offset) {
    let s = 0 - offset
    return Builtin.advance_pointer pointer s.value
}

// int
@public @inline @operator(80)
func + :: Int Int -> Int = (a b) {
    let v = Builtin.i_add a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(80)
func - :: Int Int -> Int = (a b) {
    let v = Builtin.i_sub a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(100)
func * :: Int Int -> Int = (a b) {
    let v = Builtin.i_mul a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(20)
func == :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_eq a.value b.value)

@public @inline @operator(20)
func != :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_neq a.value b.value)

@public @inline @operator(100)
func / :: Int Int -> Int = (a b) {
    //assert b != 0
    return Int (Builtin.i_div a.value b.value)
}
@public @inline @operator(90)
func % :: Int Int -> Int = (a b) do
    return Int (Builtin.i_rem a.value b.value)

@public @inline @operator(30)
func < :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lte a.value b.value)

@public @inline @operator(30)
func >= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gte a.value b.value)

@public @inline @operator(30)
func > :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gt a.value b.value)

@public @inline @operator(50)
func << :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shl a.value b.value)

@public @inline @operator(50)
func >> :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shr a.value b.value)

@public @inline @operator(95)
func ~& :: Int Int -> Int = (a b) do
    return Int (Builtin.i_and a.value b.value)

@public @inline @operator(90)
func ~| :: Int Int -> Int = (a b) do
    return Int (Builtin.i_or a.value b.value)

@public @inline @operator(90)
func ~^ :: Int Int -> Int = (a b) do
    return Int (Builtin.i_xor a.value b.value)



// bool
@public @inline @operator(15)
func && :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_and a.value b.value)

@public @inline @operator(10)
func || :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_or a.value b.value)
// TODO:: ! prefix operator


// float
@public @inline @operator(80)
func + :: Double Double -> Double = (a b) do
    return Double (Builtin.f_add a.value b.value)

@public @inline @operator(80)
func - :: Double Double -> Double = (a b) do
    return Double (Builtin.f_sub a.value b.value)

@public @inline @operator(100)
func * :: Double Double -> Double = (a b) do
    return Double (Builtin.f_mul a.value b.value)

@public @inline @operator(100)
func / :: Double Double -> Double = (a b) do
    return Double (Builtin.f_div a.value b.value)

@public @inline @operator(90)
func % :: Double Double -> Double = (a b) do
    return Double (Builtin.f_rem a.value b.value)

@public @inline @operator(30)
func < :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lte a.value b.value)

@public @inline @operator(30)
func > :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gt a.value b.value)

@public @inline @operator(30)
func >= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gte a.value b.value)

@public @inline @operator(20)
func == :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_eq a.value b.value)

@public @inline @operator(20)
func != :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_neq a.value b.value)





type Range {
    var start: Int, end: Int
    init Range = (val) {
        start = val.start
        end = val.end
    }
    
    /// A generator -- yields each element in the range
    func generate:: -> Int = {
        var i = start
        while (i < end) {
            yield i
            i = i + 1
        }
    }
}

// ranges
@public @inline @operator(40)
func ... :: Int Int -> Range = (a b) do
    return Range a b

@public @inline @operator(40)
func ..< :: Int Int -> Range = (a b) do
    return Range a b-1




type UTF8CodeUnit {
    let unit: Builtin.Int8
    
    init Int = (u) {
        unit = Builtin.trunc_int_8 u.value
    }
}

type UTF16CodeUnit {
    let unit: Builtin.Int16
    
    init Int = (u) {
        unit = Builtin.trunc_int_16 u.value
    }
}

type String {
    var base: Builtin.OpaquePointer, length: Int, _capacityAndEncoding: Int
    
    init Builtin.OpaquePointer Builtin.Int Builtin.Bool = (ptr count isUTF8Encoded) {
        // allocate the string buffer and copy in from the string ptr we are given
        base = Builtin.heap_alloc count
        Builtin.mem_copy base ptr count
        
        let c = Int count
        length = c - 1
        // store the capacity in the most significant 63 bits of _capacityAndEncoding
        _capacityAndEncoding = c << 1
        
        // if it is UTF-8 we store true in the least significant bit of _capacityAndEncoding
        if (Bool isUTF8Encoded) do
             _capacityAndEncoding = _capacityAndEncoding ~| 1
    }
    
    //@private init UTF8CodeUnit = (unit) {
    //    let b = Builtin.heap_alloc 2 // alloc 2 bytes
    //    let s = String
    //}
    
    /// Whether the string has UTF-8 encoding. if true it is a contiguous block of char*
    func isUTF8Encoded:: -> Bool = do
        return _capacityAndEncoding ~& 1 == 1
    
    /// The size of the allocated string buffer
    func bufferCapacity:: -> Int = do
        return _capacityAndEncoding >> 1
    
    /// Return a pointer to the code unit `index` from `base`
    /// temporary substitute until I have StringCore subscripting
    func codeUnitAtIndex:: Int -> Builtin.OpaquePointer = (index) do
        return base + index
    
    /// A genrator -- yields each code unit
    func generate:: -> UTF8CodeUnit = {
        var i = 0
        while i < self.bufferCapacity () {
            yield UTF8CodeUnit (Builtin.opaque_load (self.codeUnitAtIndex i))
            i = i + 1
        }
    }
}


@inline func _print :: String = (str) {
    if str.isUTF8Encoded () {
        // if its all UTF-8 we can just fwrite the buffer
        vist_cshim_write str.base str.length.value
        return ()
    } else {
        // otherwise we step through, char by char, and putchar it
        for c in str do
            vist_cshim_putchar c.unit
        return ()
    }
    // there's a CFG bug where implict `return ()` are only added to the exit point
}

@public func print :: String = (str) {
    _print str
    _print "\n"
}

@public @inline func print :: Int = (a) {
    _print (a.description ())
    _print "\n"
}
@public @inline func print :: Bool = (b) {
    _print (b.description ())
    _print "\n"
}


// TODO: a printing protocol which allows any type to generate its string repr
//       then the print function steps through that string and prints it,
//       appending terminators and doing any formatting

//concept Printable {
//    func description::->String
//}
//
//func print::Printable = (thing) do

