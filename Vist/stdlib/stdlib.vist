

// ----------------------------------------------------
// types
// ----------------------------------------------------

type Int {
    var value: Builtin.Int64
    
    init () = {
        let v = 0
        value = v.value
    }
    init Int = (val) do value = val.value
}
type Int32 {
    var value: Builtin.Int32
    init Int32 = (val) do value = val.value
}

type Bool {
    var value: Builtin.Bool
    
    init () = {
        let b = false
        value = b.value
    }
    init Bool = (val) do value = val.value
}

type Double {
    var value: Builtin.Double
    init Double = (val) do value = val.value
}

type Range {
    var start: Int, end: Int
    init Range = (val) {
        start = val.start
        end = val.end
    }
}


//type Array {
//
//    var count: Int
//    var capacity: Int
//    var ptr: Builtin.Pointer
//
//}


// ----------------------------------------------------
// free functions
// ----------------------------------------------------

@public @inline func print :: Int = (a) do vist_print a.value
@public @inline func print :: Int32 = (a) do vist_print a.value
@public @inline func print :: Bool = (a) do vist_print a.value
@public @inline func print :: Double = (a) do vist_print a.value


// TODO: print message

@inline func _expect :: Bool Bool -> Bool = (val assume) do
    return Bool (Builtin.expect val.value assume.value)

@public @inline @noreturn func fatalError :: () = do Builtin.trap ()
//@public @inline func assert :: Bool = do
//    if _expect $0 true do () else do Builtin.trap ()



// ----------------------------------------------------
// operators
// ----------------------------------------------------


@public @inline @operator(80)
func + :: Builtin.OpaquePointer Int -> Builtin.OpaquePointer = (pointer offset) do
    return Builtin.advance_pointer pointer offset.value

// int
@public @inline @operator(80)
func + :: Int Int -> Int = (a b) {
    let v = Builtin.i_add a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(80)
func - :: Int Int -> Int = (a b) {
    let v = Builtin.i_sub a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(100)
func * :: Int Int -> Int = (a b) {
    let v = Builtin.i_mul a.value b.value
    Builtin.cond_fail v.1
    return Int v.0
}

@public @inline @operator(20)
func == :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_eq a.value b.value)

@public @inline @operator(20)
func != :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_neq a.value b.value)

@public @inline @operator(100)
func / :: Int Int -> Int = (a b) {
    //assert b != 0
    return Int (Builtin.i_div a.value b.value)
}
@public @inline @operator(90)
func % :: Int Int -> Int = (a b) do
    return Int (Builtin.i_rem a.value b.value)

@public @inline @operator(30)
func < :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_lte a.value b.value)

@public @inline @operator(30)
func >= :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gte a.value b.value)

@public @inline @operator(30)
func > :: Int Int -> Bool = (a b) do
    return Bool (Builtin.i_cmp_gt a.value b.value)

@public @inline @operator(50)
func << :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shl a.value b.value)

@public @inline @operator(50)
func >> :: Int Int -> Int = (a b) do
    return Int (Builtin.i_shr a.value b.value)

@public @inline @operator(95)
func ~& :: Int Int -> Int = (a b) do
    return Int (Builtin.i_and a.value b.value)

@public @inline @operator(90)
func ~| :: Int Int -> Int = (a b) do
    return Int (Builtin.i_or a.value b.value)

@public @inline @operator(90)
func ~^ :: Int Int -> Int = (a b) do
    return Int (Builtin.i_xor a.value b.value)



// bool
@public @inline @operator(15)
func && :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_and a.value b.value)

@public @inline @operator(10)
func || :: Bool Bool -> Bool = (a b) do
    return Bool (Builtin.b_or a.value b.value)
// TODO:: ! prefix operator


// float
@public @inline @operator(80)
func + :: Double Double -> Double = (a b) do
    return Double (Builtin.f_add a.value b.value)

@public @inline @operator(80)
func - :: Double Double -> Double = (a b) do
    return Double (Builtin.f_sub a.value b.value)

@public @inline @operator(100)
func * :: Double Double -> Double = (a b) do
    return Double (Builtin.f_mul a.value b.value)

@public @inline @operator(100)
func / :: Double Double -> Double = (a b) do
    return Double (Builtin.f_div a.value b.value)

@public @inline @operator(90)
func % :: Double Double -> Double = (a b) do
    return Double (Builtin.f_rem a.value b.value)

@public @inline @operator(30)
func < :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lt a.value b.value)

@public @inline @operator(30)
func <= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_lte a.value b.value)

@public @inline @operator(30)
func > :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gt a.value b.value)

@public @inline @operator(30)
func >= :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_cmp_gte a.value b.value)

@public @inline @operator(20)
func == :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_eq a.value b.value)

@public @inline @operator(20)
func != :: Double Double -> Bool = (a b) do
    return Bool (Builtin.f_neq a.value b.value)



// ranges
@public @inline @operator(40)
func ... :: Int Int -> Range = (a b) do
    return Range a b

@public @inline @operator(40)
func ..< :: Int Int -> Range = (a b) do
    return Range a b-1



type String {
    var base: Builtin.OpaquePointer, length: Int, _capacityAndEncoding: Int
    
    init Builtin.OpaquePointer Builtin.Int Builtin.Bool = (ptr count isUTF8Encoded) {
        // allocate the string buffer and copy in from the string ptr we are given
        base = Builtin.heap_alloc count
        Builtin.mem_copy base ptr count
        
        let c = Int count
        length = c - 1
        // store the capacity in the most significant 63 bits of _capacityAndEncoding
        _capacityAndEncoding = c << 1
        
        // if it is UTF-8 we store true in the least significant bit of _capacityAndEncoding
        if (Bool isUTF8Encoded) do
             _capacityAndEncoding = _capacityAndEncoding ~| 1
    }
    
    /// Whether the string has UTF-8 encoding. if true it is a contiguous block of char*
    func isUTF8Encoded:: -> Bool = do
        return _capacityAndEncoding ~& 1 == 1
    
    /// The size of the allocated string buffer
    func bufferCapacity:: -> Int = do
        return _capacityAndEncoding >> 1
    
    /// Return a pointer to the code unit `index` from `base`
    /// temporary substitute until I have StringCore subscripting
    func codeUnitAtIndex::Int->Builtin.OpaquePointer = (index) do
        return base + index
}


@public @inline func print :: String = (str) {
    if str.isUTF8Encoded () {
        /// if its all UTF-8 we can just fwrite the buffer
        vist_cshim_write str.base str.length.value
        return ()
    } else {
        // otherwise we step through, char by char, and putchar it
        for i in 0 ..< str.bufferCapacity () do
            vist_cshim_putchar (Builtin.opaque_load (str.codeUnitAtIndex i))
        return ()
    }
    // there's a CFG bug where implict `return ()` are only added to the exit point
}

// TODO: a printing protocol which allows any type to generate its string repr
//       then the print function steps through that string and prints it,
//       appending terminators and doing any formatting

//concept Printable {
//    func description::->String
//}
//
//func print::Printable = (thing) do


