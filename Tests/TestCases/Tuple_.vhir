
type %Int = { %Builtin.Int64 }
type %Foo = { %Bar, %Bool }
type %Bool = { %Builtin.Bool }
type %Bar = { %Bool, %Int, %Int }

func @main : &thin () -> %Builtin.Void {
$entry:
  %0 = bool_literal false  	// user: %1
  %1 = struct %Bool (%0: %Builtin.Bool)  	// user: %6
  %2 = int_literal 1  	// user: %3
  %3 = struct %Int (%2: %Builtin.Int64)  	// user: %6
  %4 = int_literal 1  	// user: %5
  %5 = struct %Int (%4: %Builtin.Int64)  	// user: %6
  %6 = call @Bar_Bool_Int_Int (%1: %Bool, %3: %Int, %5: %Int)  	// user: %9
  %7 = bool_literal false  	// user: %8
  %8 = struct %Bool (%7: %Builtin.Bool)  	// user: %9
  %9 = call @Foo_Bar_Bool (%6: %Bar, %8: %Bool)  	// user: %11
  %10 = alloc %Foo  	// users: %11, %14, %17, %28
  store %9 in %10: %*Foo 
  %12 = bool_literal true  	// user: %13
  %13 = struct %Bool (%12: %Builtin.Bool)  	// user: %16
  %14 = struct_element %10: %*Foo, #Foo.a  	// user: %15
  %15 = struct_element %14: %*Bar, #Bar.x  	// user: %16
  store %13 in %15: %*Bool 
  %17 = load %10: %*Foo  	// user: %18
  %18 = struct_extract %17: %Foo, #Foo.a  	// user: %19
  %19 = struct_extract %18: %Bar, #Bar.x  	// user: %20
  %20 = call @print_Bool (%19: %Bool) 
  %21 = int_literal 1  	// user: %22
  %22 = struct %Int (%21: %Builtin.Int64)  	// user: %29
  %23 = int_literal 2  	// user: %24
  %24 = struct %Int (%23: %Builtin.Int64)  	// user: %27
  %25 = int_literal 2  	// user: %26
  %26 = struct %Int (%25: %Builtin.Int64)  	// user: %27
  %27 = tuple (%24: %Int, %26: %Int)  	// user: %29
  %28 = load %10: %*Foo  	// user: %29
  %29 = tuple (%22: %Int, %27: (%Int, %Int), %28: %Foo)  	// user: %31
  %30 = alloc (%Int, (%Int, %Int), %Foo)  	// users: %31, %34, %41, %45, %48, %51
  store %29 in %30: %*Int.Int.Int.tuple.Foo.tuple 
  %32 = int_literal 2  	// user: %33
  %33 = struct %Int (%32: %Builtin.Int64)  	// user: %35
  %34 = tuple_element %30: %*Int.Int.Int.tuple.Foo.tuple, 0  	// user: %35
  store %33 in %34: %*Int 
  %36 = int_literal 1  	// user: %37
  %37 = struct %Int (%36: %Builtin.Int64)  	// user: %40
  %38 = int_literal 1  	// user: %39
  %39 = struct %Int (%38: %Builtin.Int64)  	// user: %40
  %40 = tuple (%37: %Int, %39: %Int)  	// user: %42
  %41 = tuple_element %30: %*Int.Int.Int.tuple.Foo.tuple, 1  	// user: %42
  store %40 in %41: %*Int.Int.tuple 
  %43 = int_literal 4  	// user: %44
  %44 = struct %Int (%43: %Builtin.Int64)  	// user: %47
  %45 = tuple_element %30: %*Int.Int.Int.tuple.Foo.tuple, 1  	// user: %46
  %46 = tuple_element %45: %*Int.Int.tuple, 1  	// user: %47
  store %44 in %46: %*Int 
  %48 = load %30: %*Int.Int.Int.tuple.Foo.tuple  	// user: %49
  %49 = tuple_extract %48: (%Int, (%Int, %Int), %Foo), 0  	// user: %50
  %50 = call @print_Int (%49: %Int) 
  %51 = load %30: %*Int.Int.Int.tuple.Foo.tuple  	// user: %52
  %52 = tuple_extract %51: (%Int, (%Int, %Int), %Foo), 1  	// user: %53
  %53 = tuple_extract %52: (%Int, %Int), 1  	// user: %54
  %54 = call @print_Int (%53: %Int) 
  return ()
}

func @Bar_Bool_Int_Int : &thin (%Bool, %Int, %Int) -> %Bar {
$entry(%$0: %Bool, %$1: %Int, %$2: %Int):
  %self = alloc %Bar  	// users: %x, %b, %a, %3
  %x = struct_element %self: %*Bar, #Bar.x  	// user: %0
  %b = struct_element %self: %*Bar, #Bar.b  	// user: %1
  %a = struct_element %self: %*Bar, #Bar.a  	// user: %2
  store %$0 in %x: %*Bool 
  store %$1 in %b: %*Int 
  store %$2 in %a: %*Int 
  %3 = load %self: %*Bar  	// user: %4
  return %3
}

func @Foo_Bar_Bool : &thin (%Bar, %Bool) -> %Foo {
$entry(%$0: %Bar, %$1: %Bool):
  %self = alloc %Foo  	// users: %a, %b, %2
  %a = struct_element %self: %*Foo, #Foo.a  	// user: %0
  %b = struct_element %self: %*Foo, #Foo.b  	// user: %1
  store %$0 in %a: %*Bar 
  store %$1 in %b: %*Bool 
  %2 = load %self: %*Foo  	// user: %3
  return %2
}

func @print_Bool : &thin (%Bool) -> %Builtin.Void

func @print_Int : &thin (%Int) -> %Builtin.Void