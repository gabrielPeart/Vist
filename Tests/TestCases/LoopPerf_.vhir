
type %Int = { %Builtin.Int64 }
type %Range = { %Int, %Int }
type %Bool = { %Builtin.Bool }

func @main : &thin () -> %Builtin.Void {
$entry:
  %0 = int_literal 0  	// user: %1
  %1 = struct %Int (%0: %Builtin.Int64)  	// user: %4
  %2 = int_literal 5000000  	// user: %3
  %3 = struct %Int (%2: %Builtin.Int64)  	// user: %4
  %4 = call @..._Int_Int (%1: %Int, %3: %Int)  	// users: %5, %6
  %5 = struct_extract %4: %Range, #Range.start  	// user: %7
  %6 = struct_extract %4: %Range, #Range.end  	// user: %8
  %7 = struct_extract %5: %Int, #Int.value  	// user: %count.it
  %8 = struct_extract %6: %Int, #Int.value  	// user: %41
  break $loop(%7: %Builtin.Int64)

$loop(%loop.count: %Builtin.Int64):			// preds: entry, exit
  %10 = struct %Int (%7: %Builtin.Int64)  	// users: %13, %22, %27, %38
  %11 = int_literal 3  	// user: %12
  %12 = struct %Int (%11: %Builtin.Int64)  	// user: %13
  %13 = call @%_Int_Int (%10: %Int, %12: %Int)  	// user: %16
  %14 = int_literal 0  	// user: %15
  %15 = struct %Int (%14: %Builtin.Int64)  	// user: %16
  %16 = call @-E-E_Int_Int (%13: %Int, %15: %Int)  	// user: %17
  %17 = struct_extract %16: %Bool, #Bool.value  	// user: 
  break %17: %Builtin.Bool, $if.0, $fail.0

$loop.exit:			// preds: exit
  return ()

$if.0:			// preds: loop
  %20 = int_literal 3  	// user: %21
  %21 = struct %Int (%20: %Builtin.Int64)  	// user: %22
  %22 = call @-A_Int_Int (%10: %Int, %21: %Int)  	// user: %23
  %23 = call @print_Int (%22: %Int) 
  break $exit

$fail.0:			// preds: loop
  %25 = int_literal 1000  	// user: %26
  %26 = struct %Int (%25: %Builtin.Int64)  	// user: %27
  %27 = call @%_Int_Int (%10: %Int, %26: %Int)  	// user: %30
  %28 = int_literal 0  	// user: %29
  %29 = struct %Int (%28: %Builtin.Int64)  	// user: %30
  %30 = call @-E-E_Int_Int (%27: %Int, %29: %Int)  	// user: %31
  %31 = struct_extract %30: %Bool, #Bool.value  	// user: 
  break %31: %Builtin.Bool, $if.1, $fail.1

$if.1:			// preds: fail.0
  %33 = int_literal 1000000  	// user: %34
  %34 = struct %Int (%33: %Builtin.Int64)  	// user: %35
  %35 = call @print_Int (%34: %Int) 
  break $exit

$fail.1:			// preds: fail.0
  break $else.2

$else.2:			// preds: fail.1
  %38 = call @print_Int (%10: %Int) 
  break $exit

$exit:			// preds: if.0, if.1, else.2
  %40 = int_literal 1  	// user: %count.it
  %count.it = builtin i_add_overflow %7: %Builtin.Int64, %40: %Builtin.Int64  	// users: %41, %42
  %41 = builtin cmp_lte %count.it: %Builtin.Int64, %8: %Builtin.Int64  	// user: 
  break %41: %Builtin.Bool, $loop(%count.it: %Builtin.Int64), $loop.exit
}

func @..._Int_Int : &thin (%Int, %Int) -> %Range

func @%_Int_Int : &thin (%Int, %Int) -> %Int

func @-E-E_Int_Int : &thin (%Int, %Int) -> %Bool

func @-A_Int_Int : &thin (%Int, %Int) -> %Int

func @print_Int : &thin (%Int) -> %Builtin.Void