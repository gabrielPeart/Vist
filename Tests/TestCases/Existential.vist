
concept Eq {
    var a: Int, b: Int
}

func foo :: Eq Int -> Int = (a b) do
    return a.b + b + a.a


type Bar {
    var x: Bool, b: Int, a: Int
}

let bar = Bar true 11 4
let foo = foo bar 2

print foo // test: 17




concept TestC {
    var t: Int
}

type Foo {
    var t: Int
}

type Baz {
    var foo: TestC
}

let b = Baz (Foo 1)
let u = b.foo.t
print u // test: 1

type StackOf2 {
var bottom: Int
var top: Int

func sum :: () -> Int = do
return bottom + top

@mutating
func pop :: () -> Int = {
let v = top
top = bottom
return v
}

@mutating
func push :: Int = (val) {
bottom = top
top = val
}
}

var stack = StackOf2 2 10

print (stack.sum ()) // test: 12

stack.push 3
print (stack.bottom) // test: 10
print (stack.top) // test: 3
print (stack.sum ()) // test: 13

print (stack.pop ()) // test: 3
print (stack.pop ()) // test: 10

stack = StackOf2 2 4

print stack.bottom == stack.top // test: false

